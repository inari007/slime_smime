<?php

/**
 * SLIME S/MIME Plugin
 *
 * Copyright (c) 2025 Zdenek Dobes
 * See README file for more details.
 * 
 */

/**
 * This class represents message being composed
 * Used by processMessageToSend() method
 * Extends Mail_mime to be able to access build_params
*/

class slime_message extends Mail_mime{

    public $from;
    public $to;
    public $message;
    public $header;
    public $content;
    public $contentInfo;
    public $contentDescription = "";
    public $isMsgMultipart;
    public $isMsgHTML;

    /**
     * Creates composing message object
     * 
     * @param Mail_mime $message Composing message object
     */

    function __construct(&$message){
      $this->message = $message;

      // Ensures build_params are updated
      foreach(array_keys($this->build_params) as $param){
        $this->build_params[$param] = $message->getParam($param);
      }

      $this->header = $message->headers();
      $this->content = $this->normalizeMessage($message->get());
      $this->content .= "\r\n";
      
      // Determine wheter original message was Multipart and HTML
      $this->isMsgMultipart = $this->isMessageMultipart();
      $this->isMsgHTML = $this->isHTMLMessage();
      }

    /**
     * Get message header
     * 
     * @return array Message header
     */

      function getMessageHeader(){
        return $this->header;
      }

    /**
     * Get message content
     * 
     * @return array Message content
     */

      function getMessageContent(){
        return $this->content;
      }

      /**
     * Set message content
     * 
     * @return string @content Message content
     */

     function setMessageContent($content){
      $this->content = $content;
    }

    /**
     * Normalizes message (Ensures lines end with CRLF)
     * 
     * @param string $content Message content 
     * 
     * @return string Normalized message
     */

      function normalizeMessage($content) {
        return preg_replace("/\r\n|\r|\n/", "\r\n", $content);
      }

    /**
     * Save attributes from header defining content into contentInfo
     */

      function saveContentInfo(){
        $this->contentInfo['Content-Type'] = isset($this->header["Content-Type"]) ? $this->header["Content-Type"] : null;
        $this->contentInfo['Content-Transfer-Encoding'] = isset($this->header["Content-Transfer-Encoding"]) ? $this->header["Content-Transfer-Encoding"] : null;
        $this->contentInfo['Content-ID'] = isset($this->header["Content-ID"]) ? $this->header["Content-ID"] : null;
        $this->contentInfo['Content-Description'] = isset($this->header["Content-Description"]) ? $this->header["Content-Description"] : null;
        
        // Unset empty attributes
        foreach($this->contentInfo as $attribute => $parameters){
          if($parameters == null){
            unset($this->contentInfo[$attribute]);
          }
        }
      }

    /**
     * Sets From attribute in the header
     */

      function setFrom($subject){

        // Replaces only email value in <$email>
        $currentFrom = $this->header['From'];
        $newFrom = preg_replace('/<[^>]*>/', "<$subject>", $currentFrom);

        $this->header['From'] = $newFrom;
        $this->message->headers['From'] = $newFrom;
      }

    /**
     * Prepends information about content to the body of the message
     */

      function prependContentInfoToContent(){
        $header = "";
        foreach($this->contentInfo as $attribute => $parameters){
          $header .= $attribute . ": " . $parameters . "\r\n";
        }
        $this->content = $header . "\r\n" . $this->content;
      }

    /**
     * Removes attributes defining content from header
     */

      function removeContentInfoFromHeader(){
        $this->header = array_diff_key($this->header, array_flip(["Content-Type"]));
        $this->header = array_diff_key($this->header, array_flip(["Content-Transfer-Encoding"]));
        $this->header = array_diff_key($this->header, array_flip(["Content-ID"]));
        $this->header = array_diff_key($this->header, array_flip(["Content-Description"]));
      }

    /**
     * Checks if message contains a multipart content type 
     * 
     * @return bool True if message is multipart
     */

      function isMessageMultipart(){
        return strpos($this->header["Content-Type"], "multipart/"); 
      }

    /**
     * Removes additional description generated by OpenSSL signing.
     * 
     * @param string $message Message content
     * 
     * @return string Adjusted message content
     */

      function removeAdditionalText($message){
        return preg_replace('/This is an S\/MIME signed message(?:\r?\n){2}/', "", $message);
      }

    /**
     * Checks if message includes HTML content
     * 
     * @return bool True if message includes HTML content
     */

      function isHTMLMessage(){
        return strpos($this->content, "\r\nContent-Type: text/html"); 
      }

    /**
     * Sets new message header and content
     * 
     * @param string $message Raw message 
     */

      function setMessage($message){

        list($header, $body) = preg_split('/\r?\n\r?\n/', $message, 2);

        $this->header = $this->parseMimeHeaders($header);
        $this->content = $body;
      }

    /**
     * Converts header string to array 
     * 
     * @param string $originalHeader Raw message
     * 
     * @return array $message Raw message  
     */

      function parseMimeHeaders($originalHeader){
        $headers = array();
        $lines = preg_split("/\r?\n/", $originalHeader);
    
        foreach($lines as $line){

          // Regex for separating attributes and their values
            if(preg_match('/^([\w\-]+):\s*(.*)$/', $line, $matches)){

                $attributeName = $matches[1];
                $attributeValue = $matches[2];
    
                // If attribute already has a value, append it 
                if(isset($headers[$attributeName])){
                    $headers[$attributeName] .= " " . $attributeValue;
                }
                else{
                    $headers[$attributeName] = $attributeValue;
                }
            }

            // If values of attribute keeps going on the next line 
            else if(preg_match('/^\s+(.*)$/', $line, $matches) && !empty($headers)){
                $lastKey = array_key_last($headers);
                $headers[$lastKey] .= " " . trim($matches[1]);
            }
        }
    
        return $headers;
    }

    function setPKCS7ContentType($messageContent, $useNewerPKCS7, $operation){

      // Replace first and last occurance of application/<x->pkcs7-signature (first protocol value, last signature content type)
      if($operation == "sign"){
        $newVal = $useNewerPKCS7 ? "application/pkcs7-signature" : "application/x-pkcs7-signature";
        
        preg_match_all('/application\/x\-pkcs7\-signature|application\/pkcs7\-signature/', $messageContent, $matches, PREG_OFFSET_CAPTURE);
        $firstMatch = $matches[0][0];
        $messageContent = substr_replace($messageContent, $newVal, $firstMatch[1], strlen($firstMatch[0]));

        preg_match_all('/application\/x\-pkcs7\-signature|application\/pkcs7\-signature/', $messageContent, $matches, PREG_OFFSET_CAPTURE);
        $lastMatch = end($matches[0]);
        $messageContent = substr_replace($messageContent, $newVal, $lastMatch[1], strlen($lastMatch[0]));
        
        return $messageContent;
      }

      // Replace first occurance of application/<x->pkcs7-mime
      else{
        $newVal = $useNewerPKCS7 ? "application/pkcs7-mime;" : "application/x-pkcs7-mime;";
        return preg_replace('/application\/pkcs7-mime;|application\/x-pkcs7-mime;/', $newVal, $messageContent, 1);
      }
        
    }

      /**
       * Removes MIME-Version line that is generated by signing/encrypting content
       * 
       * @param string $messageContent Raw message
       * 
       * @return string $message Modified raw message 
       */

      function removeSecondMimeVersion($messageContent) {
        $pattern = "/^MIME-Version: 1\.0(\r\n|\n)/m";

        if (preg_match_all($pattern, $messageContent, $matches, PREG_OFFSET_CAPTURE) > 1) {
          
          $secondMatch = $matches[0][1]; 
          $secondPos = $secondMatch[1]; 
          $fullMatch = $secondMatch[0];

          $messageContent = substr_replace($messageContent, '', $secondPos, strlen($fullMatch));
        }
        return $messageContent;
      }

      /**
       * Prepends saved content attributes before the content of the message 
       * 
       * @param string $messageContent Raw message
       * 
       * @return string $message Modified raw message 
       */

      function appendContentInfo($messageContent){
        $pos = strrpos($messageContent, $this->content);

        // Create a header
        $replacement = "";
          foreach($this->contentInfo as $attribute => $parameters){
            $replacement .= $attribute . ": " . $parameters . "\r\n"; 
          }
          $replacement .= "\r\n";
          $replacement .= $this->content;
  
          return substr_replace($messageContent, $replacement, $pos, strlen($this->content));
      }

    /**
     * Get E-mail addresses of all recipients of the message
     * 
     * @param slime_smime $slime Plugin class
     * 
     * @return array E-mail addresses
     */

    function getAllRecipients($slime){
      $line = $this->header['To'];
      $recipients = explode(",", $line);

      $out = array();
      foreach($recipients as $recipient){

        // E-mail Regex
        preg_match('/<?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})>?/', trim($recipient), $matches);
        array_push($out, $slime->settings->emailToFolderName($matches[1]) . ".crt");
      }
      
      return $out;
    }

    /**
     * Get values of all the specific attribute
     * 
     * @param string $attributeName Name of the attribute
     * 
     * @return array Values of the attribute
     */

    function getParametersFromAttribute($attributeName){
      $line = $this->header[$attributeName];
      $parameters = explode(";", $line);
      $out = array();

      // Saves first value that is not a pair
      $out[$attributeName] = trim(str_replace($attributeName, "", array_shift($parameters)));

      // Saves the rest of the values
      foreach ($parameters as $parameter) {
        list($name, $value) = explode("=", $parameter);
        $name = trim($name);
        $value = trim(str_replace(['"', "'"], '', $value));
        $out[$name] = $value;
      }

      return $out;
    }

     /**
     * Converts this class into Mail_mime
     * 
     * @param array $purpose Purpose of the message
     * 
     * @return Mail_mime Message object
     */

    function convertToMailMime($purpose){

      // Replace current Content-Type with a new one
      $attributes = $this->getParametersFromAttribute("Content-Type");
      $contentType = $attributes['Content-Type'];
      unset($attributes['Content-Type']);
      $this->message->setContentType($contentType, $attributes);

      // New message body
      $messageBody = $this->content;

      // Adds optional message describing text 
      if($this->contentDescription != ""){
        $messageBody = $this->contentDescription . "\r\n\r\n" . $this->content;
      }

      if($purpose['encrypt']){
        $this->message->headers['Content-Disposition'] = 'attachment; filename="smime.p7m"';
        $this->message->headers['Content-Description'] = 'S/MIME encrypted content';
        $this->message->headers['Content-Transfer-Encoding'] = 'base64';
        $this->message->build_params['text_encoding'] = 'base64';

        // Mail_mime only allows to modify plain/text, content will be encoded again
        $messageBody = base64_decode($messageBody);
      }

      else if($purpose['sign'] && $this->isMsgMultipart){
        $this->message->headers['Content-Description'] = 'S/MIME signed content';
      }

      // HTML content became part of the signature, need to remove the original part
      if($this->isMsgHTML){
        $this->message->setHTMLBody("");
      }

      // Removing original part of the message and setting up new
      $this->message->parts = array();
      $this->message->setTXTBody($messageBody);

      return $this->message;
    }
}